\documentclass[..thesis.tex]{subfiles}

\tikzset{xyp/.style={canvas is xy plane at z=#1}}
\tikzset{xzp/.style={canvas is xz plane at y=#1}}
\tikzset{yzp/.style={canvas is yz plane at x=#1}}

\pgfmathsetmacro{\cubex}{5}
\pgfmathsetmacro{\cubey}{5}
\pgfmathsetmacro{\cubez}{5}

\newcommand{\opacity}{0.8}

% 1 - x_1, 2 - y_1, 3 - z_1, 4 - x_2, 5 - y_2, 6 - z_2, 7 - color
\newcommand{\drawcube}[7]
{
      \filldraw[opacity=\opacity, #7, draw=black, dashed, xzp=#2] (#1,#3) rectangle (#4,#6);
      \filldraw[opacity=\opacity, #7, draw=black, dashed, xzp=#5] (#1,#3) rectangle (#4,#6);
      \filldraw[opacity=\opacity, #7, draw=black, dashed, xyp=#3] (#1,#2) rectangle (#4,#5);
      \filldraw[opacity=\opacity, #7, draw=black, dashed, xyp=#6] (#1,#2) rectangle (#4,#5);
      % not drawing left side intentionally
      \filldraw[opacity=\opacity, #7, draw=black, dashed, yzp=#4] (#2,#3) rectangle (#5,#6);
}

\newcommand{\drawcubeoverz}[5]
{
 \drawcube{#1}{#2}{0}{#3}{#4}{\cubez}{#5}
}

\newcommand{\drawoutercube}
{
      \draw[thick,-] (0,0,0) -- ++(\cubex,0,0) -- ++(0,0,\cubez) -- node [anchor = north] {$B$} ++(-0.5*\cubex,0,0) --  node [anchor = north] {$A$} ++(-0.5*\cubex,0,0)  --   ++(0,0,-\cubez);
      \draw[thick,-] (0,\cubey,0) -- ++(\cubex,0,0) -- ++(0,0,\cubez) -- ++(-\cubex,0,0) --   ++(0,0,-\cubez)  ;

      \draw[thick,-] (0,0,0) -- (0,\cubey,0);
      \draw[thick,-] (\cubex,0,0) -- (\cubex,\cubey,0);
      \draw[thick,-] (\cubex,0,\cubez) -- ++(0,\cubey,0);
      \draw[thick,-] (0,0,\cubez) -- (0,\cubey,\cubez);
}

%%%%%%% Colors %%%%%%

\newcommand{\defaultPColor}{yellow}
\newcommand{\defaultPLColor}{\defaultPColor!50}
\newcommand{\defaultPRColor}{\defaultPColor!75}

\newcommand{\aColor}{blue}
\newcommand{\aLColor}{\aColor!30}
\newcommand{\aRColor}{\aColor!75}

\newcommand{\bColor}{green}
\newcommand{\bLColor}{\bColor!50}
\newcommand{\bRColor}{\bColor!95}
      
\newcommand{\bIColor}{purple}
\newcommand{\bILColor}{\bIColor!30}
\newcommand{\bIRColor}{\bIColor!95}

\newcommand{\defaultColor}{red}
\newcommand{\defaultLColor}{\defaultColor!30}
\newcommand{\defaultRColor}{\defaultColor!75}

\newcommand{\initColor}{red}
\newcommand{\initLColor}{\initColor!30}
\newcommand{\initRColor}{\initColor!75}

\newcommand{\postInitColor}{blue}
\newcommand{\postInitLColor}{\postInitColor!30}
\newcommand{\postInitRColor}{\postInitColor!75}

\begin{document}

\toguide{Okay, what's next?}

The key challenge for Goblint is the number of false-positives. It is clear that even if one can guarantee the soundness of the 
underlying analysis, then there is a threshold of incorrect warnings above what the results of the analysis contain too much noise
to be of help for a programmer.

\toguide{I buy it, what can be done about it?}

One of the steps taken to reduce the the number of false-positives is the usage of \textit{happen-before} relation.

\toguide{How can you use happen-before here?}

Consider following simplified device driver:

\begin{lstlisting}[language=c,style=def]

static int i = 0;
static int j = 0;

static int file_open(file* f, ...)
{
    printk( "Opening device \n");
    file -> private_data += 1;
    j += 1;
    return 0;
}

static int file_close(file* f, ...)
{
    printk( "Closing device \n");
    file -> private_data -= 1
    j -= 1;
    return 0;
}

int a(file f, ...)
{
  j += 1;
  return 0;
}

int b(file f, ...)
{
  j += 1
  return 0;
}

struct file_operations f_ops = {
  .open    = file_open,
  .release = file_close,
};

int init(...)
{
  publish_file_operations(f_ops);
  i += 1;
  return 0;
}

int exit(...)
{
  i -= 1;
  return 0;
}

\end{lstlisting}

As mentioned previously, \textit{init} and \textit{exit} functions are used by kernel register and deregister a device.
 As after publishing the file operations, Goblint cannot assume that the functions of the driver are called by one thread,
 a possible data-race is detected between the operations on variable $i$ in functions \textit{init} and \textit{exit}.
 At same time, the Linux Kernel does not allow a call to the \textit{exit} function until the call to the \textit{init} function is called and all the opened files are released.

We would like to have Goblin know about that guarantee and make use of the information that the call to \textit{init} will always complete before call to \textit{exit}.

\toguide{Example makes sense, but how to practically make use of it?}

To do so, we extend the region based analysis of Goblint.

\toguide{Erghh, was not the easiest part of the Goblint section. A bit of refreshment would be great.}
\tosup{I am now even more convinced that you should have a chapter on ``Region Analysis for Space and Time'' where you first describe the current region analysis and extend it with timed partitions. Then, you have a section with just implementation. The only question is where to put any experimental results.}

As discussed in previous section, Goblint tries to track the memory regions of pointers and uses this information to exclude possible data races.

\toadd{Region analyses covered in Goblint section.} 

For example, let us have two procedures , \inlinecode{f} and \inlinecode{g} that can be ran simultaneously in different threads.

\begin{lstlisting}[language=c,style=def]

int* p;
int* q;

void f()
{
  &p = &q - 1; 
}

void g()
{
  &q = &q + 1; 
}

\end{lstlisting}

 

If we can divide the memory used by the program to two regions, $A$ and $B$ that are disjoint and we can guarantee that the pointer \inlinecode{p} points
to integer variable stored in region $A$ and \inlinecode{q} points to integer variable stored in region $B$ then we can safely assume that there
can be no data-race between the increment and decrement operations in function \inlinecode{f} and \inlinecode{g}.

\begin{figure}[H]
  \centering
    \begin{tikzpicture}
      \draw[thick,-] (0,0,0)  -- ++(0,0,\cubez) --  node [anchor = north] {$A$} ++(0.5*\cubex,0,0) -- node [anchor = north] {$B$} ++(0.5*\cubex,0,0)   --  ++(0,0,-\cubez) -- ++(-\cubex,0,0);
      \draw[thick,dashed] (0.5*\cubex,0,0) -- ++(0,0,\cubez);
      \fill[opacity=\opacity,red!30,draw=black,xzp=0] (0,0) rectangle (2.5,5);
      \fill[opacity=\opacity,red!75,draw=black,xzp=0] (2.5,0) rectangle (5,5);

      \node at (0.15*\cubex,0,0.6*\cubez) (p) {\figcode{\&p}};
      \node at (0.8*\cubex,0,0.75*\cubez) (q) {\figcode{\&q}};

      \node at (0.35*\cubex,0,0.35*\cubez) (q) {\figcode{i}};
    \end{tikzpicture}
    \caption{Memory partition as done by region analyses}
\end{figure}

Going back to the example driver, this does allow to eliminate the data race between the assignments to \inlinecode{i} in \inlinecode{init} and \inlinecode{exit} functions.
However, if we would enhance the region analyses with one more dimension that would roughly correspond to time,
we could divide the memory as seen on the following illustration. 

\begin{figure}[H]
  \centering
    \begin{tikzpicture}

      \drawcubeoverz{0}{0}{0.5*\cubex}{0.5*\cubey}{\initLColor}
      
      \drawcubeoverz{0}{0.5*\cubey}{0.5*\cubex}{\cubey}{\postInitLColor}

      \drawcubeoverz{0.5*\cubex}{0}{\cubex}{0.5*\cubey}{\initRColor}      

      \drawcubeoverz{0.5*\cubex}{0.5*\cubey}{\cubex}{\cubey}{\postInitRColor}

      \drawoutercube

      \node at (0.285*\cubex,0.15*\cubey,0.7*\cubez) (ip) {\figsubcode{i}{init}};
      \node at (0.285*\cubex,0.8*\cubey,0.7*\cubez) (i) {\figsubcode{i}{exit}};

      \draw[thick,-] (0,0,\cubez) -- node[anchor= east] {$init$} ++(0,0.5*\cubey,0)  -- node[anchor= east] {$postInit$}  ++(0,0.5*\cubey,0);
    \end{tikzpicture}
    \caption{Memory partition with addition of time dimension}
\end{figure}

This would let Goblint exclude the possibility of race between these two operations. 

\toguide{How is it done?}

To do this, Goblint needs to track information for each read and write operation.

\toask{operation bad word?}

The information tracked is divided into \textit{left} and \textit{right} side. 

On the left side, information regarding the memory region of the variable is stored as a set of sets, $C$,
 such that every element of $C$, $I$ describes an intersection of memory regions.

In our example driver, the $C$ for the increment operation on $i$ in the $init$ function would be 

\begin{equation*}
\lb \lb A, init \rb \rb \text{.}
\end{equation*} 

On the right side, information regarding possible reasons why data race cannot take place with another read or write operation is stored in a set $M$.
 For an example, $M$ could contain the set of locks held at the specific operation or whether or not the thread running the procedure containing the operation is guaranteed to be unique.

When deciding if there is a possibility of a data race between operations $a$ and $b$, Goblint uses two predicates, $L$ and $R$ to evaluate left and right sides of these operations. 

The first of those predicates is defined as follows

\begin{equation*}
L \lp C_a, C_b \rp =  C_a \cap C_b \neq \emptyset \text{.}
\end{equation*}

If $L \lp C_a, C_b \rp$ evaluates to false it means that the two operations do not share a common memory region and hence there cannot be a data race. 

The second predicate, $R$ evaluates the sets $M_a$ and $M_b$ and returns true if there is something that guarantees that the operations $a$ and $b$ cannot race.
 For example, it could be when performing both of these operations, lock $l$ must be held or in case of $a=b$,
 there is a guarantee that there can be only one thread running that executes the operation.

Equipped with those definitions, we can guarantee that operations $a$ and $b$ cannot race if the implication

\begin{equation}
\label{implication}
L \lp C_a, C_b \rp \implies R \lp M_a, M_b \rp  
\end{equation}

holds.

Coming back to our example driver, one can see that using the enhanced region analyses, we can now see that there cannot be a race between $i_{init}$ and $i_{exit}$.
Indeed, as

\toask{Or should we take A as a set of regions, i.e instead of $\lb A, init \rb $ have $C_A \cup \lb init \rb$ ? Would be more correct, but increases complexity?}

\begin{equation*}
 \lb \lb A, init \rb \rb \cap  \lb \lb A, postInit \rb \rb = \emptyset
\end{equation*}

then $L \lp C_{i_{init}}, C_{i_{postInit}} \rp$ is false and the implication (\ref{implication}) holds for $i_{init}$ and $i_{exit}$.

As an example of right hand sides excluding an data race, if we take both $a$ and $b$ to be $i_{init}$ then when evaluating 

\begin{equation*}
R \lp M_{i_{init}}, M_{i_{init}} \rp
\end{equation*} 

we can take into account that Linux kernel does not allow one to register the same driver more than once and as such,
 we can guarantee that the thread running the $init$ function is unique.

Based on that information $R \lp M_{i_{init}}, M_{i_{init}} \rp$ holds and so does the implication (\ref{implication}).

\toguide{Does this thing scale, anything else you can do other than init/exit?}

One might have noticed that our example drivers has two extra function, $a$ and $b$. Lets now suppose that similar property holds for $a$ and $b$ --
 during the lifetime of driver, we can only call $a$ once and $b$ once and call to $a$  must happen before call to $b$.

Let this be the regions of the program, enhanced with the extra dimension, taking into account only the division by $a$ and $b$:

%%%%%%%%%%%%%%%%%%%%% Height values for a and b %%%%%%%%%%%%%%%%%%%%

 \pgfmathsetmacro{\defaultH}{0.2}
 \pgfmathsetmacro{\aH}{0.45}
 \pgfmathsetmacro{\bH}{0.8}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[H]
  \centering
    \begin{tikzpicture}
      
      \drawcubeoverz{0}{0}{0.5*\cubex}{\defaultH*\cubey}{\defaultLColor}

      \drawcubeoverz{0}{\defaultH*\cubey}{0.5*\cubex}{\aH*\cubey}{\aLColor}

      \drawcubeoverz{0}{\aH*\cubey}{0.5*\cubex}{\bH*\cubey}{\bLColor}

      \drawcubeoverz{0}{\bH*\cubey}{0.5*\cubex}{\cubey}{\defaultLColor}

      \drawcubeoverz{0.5*\cubex}{0}{\cubex}{\defaultH*\cubey}{\defaultRColor}

      \drawcubeoverz{0.5*\cubex}{\defaultH*\cubey}{\cubex}{\aH*\cubey}{\aRColor}

      \drawcubeoverz{0.5*\cubex}{\aH*\cubey}{\cubex}{\bH*\cubey}{\bRColor}

      \drawcubeoverz{0.5*\cubex}{\bH*\cubey}{\cubex}{\cubey}{\defaultRColor}

      \drawoutercube

      
      \node at (0.65*\cubex,0.1*\cubey,0.4*\cubez) (ip) {\figsubcode{j}{a}};
      \node at (0.65*\cubex,0.5*\cubey,0.4*\cubez) (i) {\figsubcode{j}{b}};

      \draw[thick,-] (0,0,\cubez) -- node[anchor= east] {$default$} (0,\defaultH*\cubey,\cubez) -- node[anchor= east] {$a$}  (0,\defaultH*\cubey,\cubez)  --
      node[anchor= east] {$b$}  (0,\bH*\cubey,\cubez) -- node[anchor= east] {$default$}  (0,\cubey,\cubez);


    \end{tikzpicture}
    \caption{Memory partition with addition of time dimension by $a$ and $b$}
\end{figure}

If we want to combine this time division with the one we could find the Cartesian product of the two and use that as demonstrated on the next figure.

\begin{figure}[H]
  \centering
    \begin{tikzpicture}

      \drawcubeoverz{0}{0}{0.5*\cubex}{\defaultH*\cubey}{\defaultLColor}

      \drawcubeoverz{0}{\defaultH*\cubey}{0.5*\cubex}{\aH*\cubey}{\aLColor}

      \drawcubeoverz{0}{\aH*\cubey}{0.5*\cubex}{0.5*\cubey}{\bILColor}

      \drawcubeoverz{0}{0.5*\cubey}{0.5*\cubex}{\bH*\cubey}{\bLColor}

      \drawcubeoverz{0}{\bH*\cubey}{0.5*\cubex}{\cubey}{\defaultPLColor}

      \drawcubeoverz{0.5*\cubex}{0}{\cubex}{\defaultH*\cubey}{\defaultRColor}

      \drawcubeoverz{0.5*\cubex}{\defaultH*\cubey}{\cubex}{\aH*\cubey}{\aRColor}

      \drawcubeoverz{0.5*\cubex}{\aH*\cubey}{\cubex}{0.5*\cubey}{\bIRColor}

      \drawcubeoverz{0.5*\cubex}{0.5*\cubey}{\cubex}{\bH*\cubey}{\bRColor}
      
      \drawcubeoverz{0.5*\cubex}{\bH*\cubey}{\cubex}{\cubey}{\defaultPRColor}

      
      \node at (0.65*\cubex,0.1*\cubey,0.4*\cubez) (ip) {\figsubcode{j}{a}};
      \node at (0.65*\cubex,0.5*\cubey,0.4*\cubez) (i) {\figsubcode{j}{b}};

      \node at (0.285*\cubex,0.2*\cubey,0.65*\cubez) (ip) {\figsubcode{i}{init}};
      \node at (0.285*\cubex,0.8*\cubey,0.65*\cubez) (i) {\figsubcode{i}{exit}};

      \drawoutercube

      \draw[thick,-] (0,0,\cubez) -- node[anchor= east] {$default \land init$} (0,\defaultH*\cubey,\cubez) -- node[anchor= east] {$a \land init$}  (0,\aH*\cubey,\cubez) 
      -- node[anchor= east] {$b \land init$}  (0,0.5*\cubey,\cubez)-- node[anchor= east] {$b \land postInit$}  (0,\bH*\cubey,\cubez) --
      node[anchor= east] {$default \land postInit$}  (0,\cubey,\cubez);


    \end{tikzpicture}
    \caption{Memory partition with addition of combined time dimension}
\end{figure}

Here, the set $C$ for the increment operation of $i$ in the $init$ function would be

\begin{equation*}
\lb \lb A, init, default \rb, \lb A, init, a \rb, \lb A, init, b \rb \rb
\end{equation*}

and for the decrement operation of $j$ in $b$ it would be

\begin{equation*}
\lb \lb B, init, b \rb, \lb B, postInit, b \rb \rb \text{.}
\end{equation*}

\toguide{Wait, this does not really scale, does it?}

It is easy to see that this approach does not scale too well -- in the worst case the computational difficulty will grow exponentially with added time partition.

\toask{Memory region?}

However, lets notice that when we evaluate the left sides of two operations, the time dimension only has an effect if memory regions of the operations match. 

Indeed, let $Mem$ be the set of all memory regions, let \inlinesubcode{i}{a} and \inlinesubcode{i}{b} be two operations with left sides $C_{i_{a}}$ and $C_{i_{b}}$ such that they do not share a common memory region,
that is

\begin{equation*}
\forall \lp c_1, c_2 \rp, c_1 \in C_{i_a} , c_2 \in C_{i_b} , \lnot \lp \exists m \in Mem,  m \in c_1 \land m \in c_2 \rp
\end{equation*} 

\toask{Should require this somewhere?}

and as at same time, all the entries of the left hand side must contain a memory region then it is clear that $C_{i_{a}} \cap C_{i_{b}} = \emptyset$ and by definition,
$\lnot L \lp C_{i_{a}}, C_{i_{b}} \rp $. 

With that in mind, then for the time partition of memory region $A$ we can take Cartesian product off all the time partitions that effect an operation located in region $A$.
For our running example, the partition would look as follows:

\begin{figure}[H]
  \centering
    \begin{tikzpicture}

      \drawcubeoverz{0}{0}{0.5*\cubex}{0.5*\cubey}{cyan!40}
      
      \drawcubeoverz{0}{0.5*\cubey}{0.5*\cubex}{\cubey}{yellow!50!red}

      \drawcubeoverz{0.5*\cubex}{0}{\cubex}{\defaultH*\cubey}{\defaultRColor}

      \drawcubeoverz{0.5*\cubex}{\defaultH*\cubey}{\cubex}{\aH*\cubey}{\aRColor}

      \drawcubeoverz{0.5*\cubex}{\aH*\cubey}{\cubex}{\bH*\cubey}{\bRColor}

      \drawcubeoverz{0.5*\cubex}{\bH*\cubey}{\cubex}{\cubey}{\defaultPRColor}
      
      \node at (0.65*\cubex,0.1*\cubey,0.4*\cubez) (ip) {\figsubcode{j}{a}};
      \node at (0.65*\cubex,0.5*\cubey,0.4*\cubez) (i) {\figsubcode{j}{b}};

      \node at (0.285*\cubex,0.2*\cubey,0.65*\cubez) (ip) {\figsubcode{i}{init}};
      \node at (0.285*\cubex,0.8*\cubey,0.65*\cubez) (i) {\figsubcode{i}{exit}};

      \drawoutercube

      
      \draw[thick,-] (0,0,\cubez) -- node[anchor= east] {$init$} ++(0,0.5*\cubey,0)  -- node[anchor= east] {$postInit$}  ++(0,0.5*\cubey,0);
      \draw[thick,-] (\cubex,0,0) -- node[anchor= west] {$default$} (\cubex,\defaultH*\cubey,0) -- node[anchor= west] {$a$}  (\cubex,\aH*\cubey,0)  --
      node[anchor= west] {$b$}  (\cubex,\bH*\cubey,0) -- node[anchor= west] {$default$} (\cubex,\cubey,0);

    \end{tikzpicture}
    \caption{Memory partition with local time partition}
\end{figure}

With this partition, the set $C$ for the increment operation of $i$ in the $init$ function would be

\begin{equation*}
\lb \lb A, init \rb \rb
\end{equation*}

and for the decrement operation of $j$ in $b$ it would be

\begin{equation*}
\lb \lb B, init, b \rb \rb \text{.}
\end{equation*}


This approach scales well if we are able to divide memory into small areas and although there are no theoretical guarantees for that,
in case of Linux device drivers in the Goblint benchmark suit this is possible.

\toask{Too bold of a claim?}

\toguide{Okay, neat, solves the scaling issue. That is it?}

In addition, the finer granularity of this approach lets us easily support more specific guarantees.

Once again, consider the running example driver we have used in this section, more specifically, the functions $file\_open$ and $file\_close$.

\begin{lstlisting}[language=c,style=def]
static int file_open(file* f, ...)
{
    printk( "Opening device \n");
    file -> private_data += 1;
    j += 1;
    return 0;    j += 1;
}

static int file_close(file* f, ...)
{
    printk( "Closing device \n");
    file -> private_data -= 1
    j -= 1;
    return 0;
}
\end{lstlisting}

It is guaranteed that file $f$ can only be closed one time after it has been opened. This means that the operations on \inlinecode{file -> private\_data}
cannot race in functions \inlinecode{file\_open} and \inlinecode{file\_closed}. At same time, it is very possible that there is a race between the operations on \inlinecode{j} in \inlinecode{file\_open} and \inlinecode{file\_close}
-- it is possible that file $f_1$ is being opened at same time as $f_2$ is being closed. 

If we are able to separate the memory region only containing $file$ then we can partition this further by dividing the time dimension to $default, file\_open$ and $file\_closed$,
while not applying the same division of time dimension to the region containing $j$. 

\toguide{Neat. Is this all of any use?}

Evaluating this approach on the set of character devices used as benchmark suit for Goblint gave following result.

\toadd{Actual benchmark}

As seen by the results of the benchmark, the effect this partitioning has depends heavily on the driver.
In most of the drivers the effect can be attributed to the exclusion of races between init and exit functions. 

\toask{Should mention this?} 

It is worth noting that the motivation for introducing \textit{happens-before} based analysis to Goblint did came from analyzing the common issues on a subset of those very same drivers.
However, the fact that there were other drivers, outside the subset of the benchmark drivers that was manually analyzed,
that greatly benefited from the addition of the extra dimension leads the author to believe that there is a reasonable likelihood
that the benefits are not limited to this specific set of drivers.

\toguide{Okay, got it. Seems cool. Anything else we should know?}

The examples given for guarantees were all specific to Linux device drivers and as such, required domain knowledge to specify. This is an hindarance,
specially taking into account that the number of possible coventions that guarantee race freedom between two operations is very likely large.  

However, at the same time it is very hard to imagine a domain independent analysis that would be able to safely exclude the races that we have looked at in this section.

Currently, the rules mentioned in this section are hard-coded into Goblint. This approach does not completely solve the issue of how to make Goblint take the domain specific happen-before
guarantees into account -- sadly it is not possible for the team behind Goblint to cover all the possible domains nor even fully cover the domain of device drivers.

In the long term, offering either the user of a Goblint or an interested thirty party a way to specify those guarantees,
for example through a DSL,  would help to solve this limitation. In addition, an approach that would try to deduce possible happens-before guarantees dynamically 
could be something that would lessen the burden on the party specifying the guarantees.

\toadd{Some kind of ending}
\tosup{It would be nice to have some words about how this is implemented in slightly more low-level terms.}


\end{document}
